package HashAndHashTables;
//以下题目的blog refer to https://blog.csdn.net/ZJRUIII/article/details/126455863


// 32位无符号整数的范围是 0 - (2^32 - 1) or 40亿+, 现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没有出现过的数。
// 可以使用最多1GB内存，怎么找到所有未出现的数？

// 我们可以使用位图，创建一个由bit类型组成的数组，其中的一个下标就是1个bit。因此可以创建2的32次方个bit大小的数组。
// 又因为8个bit组成一个B，则该数组就一共有2的32次方 / 8 个B，这个是肯定在1G的范围内的，因此就满足了题目的限定条件。
//但是对于一个具体的bit(将一个整型当作一个大bit来看，对应到数组中的位置)要对应到数组中的bit，该如何设置？
//可以先创建整型数组，大小为10，即创建出了320个bit大小的数组。
// 此时要求出一个具体的i(bit)对应到数组中的哪个bit，则可以用i先除一个32，得到i归属于哪个下标表示bit位。再用i%32求出i在该部分的哪个具体位置。
//举个例子：此时有一个i为64，数组是整型数组，大小为10。则arr[0]=0~31，arr[1]=32 ~63，arr[2]=64 ~95，此时64先除32，得到2，则属于2下标的位置。
// 再用64%32=0，则在下标为2的0号bit位。得到该bit位后&1，如果得到的是1，则原本为1状态；如果得到的是0，则原本为0状态。
// 用代码表示为：int status = (arr[i/32]&(1<<(i%32)))==0?0:1;
//因此对于一个40亿整数的文件，遍历该文件中的数字，出现一个数字就用哈希函数求出哈希值再对应到数组中的bit位置，再把该位置描黑代表出现过。
// 到最后，如果bit数组中有对应的bit位没有描黑，则对应的位数就是没有出现的数字。




// 【进阶】内存限制为 3KB，但是只用找到一个没出现过的数即可
// 因为内存限制为3KB，则为3000B，如果开辟一个整型数组，那么整型数组的长度为3000B / 4B = 750 。
// 这个是刚好不会超出内存范围的。为了让2的32次方个数能够均分到数组中，我们可以将数组的大小一个离750这个数最近的2的几次方的一个数，即512。
// 因此该数组的一个下标代表的范围是2的32次方 / 512 = 8388608，因为40亿个数是在43亿个数的范围内的，则肯定有某些数是没有出现过的。
//因为按照题目要求，找到一个没出现的数即可，那么肯定能够找到不满的其中一个下标的范围。再在该范围中去找哪个数字没出现。
// 在该范围中得知有没出现的数字，我们可以再将该范围分成512份，因此在新的小范围中肯定又有不满的小范围，再把不满的新的小范围分成512份，直到定位出没出现的数为止。
// 视频讲解见 https://www.bilibili.com/video/BV13g41157hK/?p=15&spm_id_from=pageDriver&vd_source=d67679eb2bbd122f6cd7f6d142b724f3，时间2:00:03


//【进阶】只用有限几个变量，如何在40亿个无符号整数中找出一个没有出现过的数？
//        我们可以定义一个L和R，L到0位置，R到2的32次方位置。
//        进行二分，mid就是在中间的位置，划分左右两边为2的31次方那么多数。就必然存在左右两侧不够2的31次方的情况，再在不够的一侧进行二分，到最后一定能把没出现的数二分出来。
//        总结：在3K内存限制的时候，进行512分。在有限几个变量限制的时候，进行二分。

//题目三：有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
//        首先可以使用布隆过滤器，但是利用它会有失误率。如果不能有失误率，则用哈希函数进行分流的方法。
//        先对大文件中的数据用哈希函数求出哈希值，分配到小文件当中。
//        如果该小文件不能满足题目的内存限制要求，就对小文件中的数据再次进行哈希，放入到直到满足题目要求的文件中即可。主要的就是利用多次哈希。
//        视频讲解见https://www.bilibili.com/video/BV13g41157hK/?p=16&spm_id_from=pageDriver&vd_source=d67679eb2bbd122f6cd7f6d142b724f3，第10分钟


//题目四：32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。
//        可以利用位图，建立一个bit数组。每两个bit代表一个数字的出现次数的情况。
//        假设数组最前两个bit位代表的是0，后面两个bit位代表的是1，可以代表1的两个bit位进行统计出现的次数。
//        如果是00，代表1一次都没有出现；如果是01，代表出现了1次；如果是10，代表出现了两次；如果是11，代表出现了三次或三次以上。
//        出现一个数就人为地设置它代表的两个bit位，出现11之后就无需再管它。
//
//        最后遍历数组，找出哪个数对应的bit位是10的，那么就说明它出现了两次。
//
//        但是，因为我们是用两个bit位代表一个数字的出现次数，假设用一个bit位的时候，
//        数组的大小为：2的32次方 / 8 / 1000 = 536,870,912M，因为是两bit位，则再乘2，超过了1G。那么如何解决？
//
//        可以使用分段加位图的思想。我们可以先统计前半部分的2的31次方哪个数出现了两次，再统计后半部分的2的31次方哪个数出现了两次，最后就能够求出这40亿个数哪些数出现了两次。


// 题目五：32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多3K的内存，怎么找到这40亿个整数的中位数？
//分段统计思想，将数分为各个区间，然后区间内统计词频，可以知道中位数在哪个区间中，然后再将该区间在分段求解。
//
// 同样地，因为是最多3K内存，可以设置一个长度512的数组对2的32次方个数进行划分。在数组中对每个下标代表的数进行统计。如：下标0代表的数是0~8388608。
//
// 因为要找出40亿个数的中位数，那么要找出第20亿个数是哪个。如果下标0中出现的数有1亿个，那么中位数绝对不可能出现在下标0代表的某个数中。
// 假设统计0到170下标的数有19亿个，到171下标的数有23亿个，那么中位数肯定就是在171下标代表的某个数中。找到171下标中第一亿个数就是中位数。


// 题目6: 你有一个10G的文件，文件中全是无序的有符号Integer，只给你5G的内存，怎样通过一种手段输出新的文件，此文件中保留源文件中的所有数，并且这些数有序排列。
//
// 分段统计思想---使用哈希表分段统计区间词频。 具体操作---假设一个 key-value structure 需要16bytes存储(理论上为4+4=8bytes，这里我们加上了其内部的索引空间，所以是16bytes)
// 我们用我们有的5G内存除去16----(5 * 2^30) / 16 = 5 * 2^26. 我们取用2^27次方作为我们需要的哈希表数，每个表中cover 2^5个在原文件中出现数以及他们的词频，
// 并且些数按照key的大小作大根堆排序。我们loop through整个10G文件找到最小的2^5个数并把他们放在第一个哈希表中，然后进行打印。用其中最大的数作为第二个哈希表的判断条件，
// 如果遇到的数大于第一个表中最大的数，则进入第二张表，如果小于他则忽略。依此我们找到第二批最小的2^5个数放在第二个哈希表中，进行打印。以此类推
// 视频讲解见https://www.bilibili.com/video/BV13g41157hK/?p=16&spm_id_from=pageDriver&vd_source=d67679eb2bbd122f6cd7f6d142b724f3， 第40分钟
public class BitMapProblems {
}
